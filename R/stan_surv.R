# Part of the rstanarm package for estimating model parameters
# Copyright (C) 2018 Sam Brilleman
# Copyright (C) 2018 Trustees of Columbia University
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#' Bayesian survival models via Stan
#'
#' \if{html}{\figure{stanlogo.png}{options: width="25px" alt="http://mc-stan.org/about/logo/"}}
#' Bayesian inference for survival models (sometimes known as models for 
#' time-to-event data). Currently, the command fits standard parametric 
#' (exponential, Weibull and Gompertz) and flexible parametric (cubic 
#' spline-based) survival models on the hazard scale, with covariates included 
#' under assumptions of either proportional or non-proportional hazards. 
#' Where relevant, non-proportional hazards are modelled using a flexible 
#' cubic spline-based function for the time-dependent effect (i.e. the
#' time-dependent hazard ratio).
#'
#' @export
#' @importFrom splines bs
#' @import splines2
#'  
#' @template args-dots
#' @template args-priors
#' @template args-prior_PD
#' @template args-algorithm
#' @template args-adapt_delta
#' 
#' @param formula A two-sided formula object describing the model. 
#'   The left hand side of the formula should be a \code{Surv()} 
#'   object. Left censored, right censored, and interval censored data 
#'   are allowed, as well as delayed entry (i.e. left truncation). See 
#'   \code{\link[survival]{Surv}} for how to specify these outcome types. 
#'   If you wish to include time-dependent effects (i.e. time-dependent 
#'   coefficients, also known as non-proportional hazards) in the model
#'   then any covariate(s) that you wish to estimate a time-dependent 
#'   coefficient for should be specified as \code{tde(varname)}  where 
#'   \code{varname} is the name of the covariate. See the \strong{Details} 
#'   section for more information on how the time-dependent effects are 
#'   formulated, as well as the \strong{Examples} section.
#' @param data A data frame containing the variables specified in 
#'   \code{formula}.
#' @param basehaz A character string indicating which baseline hazard to use
#'   for the event submodel. Current options are: 
#'   \itemize{
#'     \item \code{"ms"}: a flexible parametric model using cubic M-splines to 
#'     model the baseline hazard. The default locations for the internal knots, 
#'     as well as the basis terms for the splines, are calculated with respect
#'     to time. If the model does \emph{not} include any time-dependendent 
#'     effects then a closed form solution is available for both the hazard
#'     and cumulative hazard and so this approach should be relatively fast.
#'     On the other hand, if the model does include time-dependent effects then
#'     quadrature is used to evaluate the cumulative hazard at each MCMC
#'     iteration and, therefore, estimation of the model will be slower.
#'     \item \code{"bs"}: a flexible parametric model using cubic B-splines to 
#'     model the \emph{log} baseline hazard. The default locations for the  
#'     internal knots, as well as the basis terms for the splines, are calculated 
#'     with respect to time. A closed form solution for the cumulative hazard 
#'     is \strong{not} available regardless of whether or not the model includes
#'     time-dependent effects; instead, quadrature is used to evaluate 
#'     the cumulative hazard at each MCMC iteration. Therefore, if your model
#'     does not include any time-dependent effects, then estimation using the 
#'     \code{"ms"} baseline hazard will be faster.
#'     \item \code{"exp"}: an exponential distribution for the event times. 
#'     (i.e. a constant baseline hazard)
#'     \item \code{"weibull"}: a Weibull distribution for the event times.
#'     \item \code{"gompertz"}: a Gompertz distribution for the event times.
#'   }
#' @param basehaz_ops A named list specifying options related to the baseline
#'   hazard. Currently this can include: \cr
#'   \itemize{
#'     \item \code{df}: a positive integer specifying the degrees of freedom 
#'     for the M-splines or B-splines. An intercept is included in the spline
#'     basis and included in the count of the degrees of freedom, such that
#'     two boundary knots and \code{df - 4} internal knots are used to generate 
#'     the cubic spline basis. The default is \code{df = 6}; that is, two 
#'     boundary knots and two internal knots.
#'     \item \code{knots}: An optional numeric vector specifying internal 
#'     knot locations for the M-splines or B-splines. Note that \code{knots} 
#'     cannot be specified if \code{df} is specified. If \code{knots} are 
#'     \strong{not} specified, then \code{df - 4} internal knots are placed 
#'     at equally spaced percentiles of the distribution of uncensored event 
#'     times.
#'   }
#'   Note that for the M-splines and B-splines - in addition to any internal
#'   \code{knots} - a lower boundary knot is placed at the earliest entry time
#'   and an upper boundary knot is placed at the latest event or censoring time.
#'   These boundary knot locations are the default and cannot be changed by the
#'   user.
#' @param qnodes The number of nodes to use for the Gauss-Kronrod quadrature
#'   that is used to evaluate the cumulative hazard when \code{basehaz = "bs"}
#'   or when time-dependent effects (i.e. non-proportional hazards) are 
#'   specified. Options are 15 (the default), 11 or 7.
#' @param prior_intercept The prior distribution for the intercept. Note 
#'   that there will only be an intercept parameter when \code{basehaz} is set
#'   equal to one of the standard parametric distributions, i.e. \code{"exp"}, 
#'   \code{"weibull"} or \code{"gompertz"}, in which case the intercept 
#'   corresponds to the parameter \emph{log(lambda)} as defined in the 
#'   \emph{stan_surv: Survival (Time-to-Event) Models} vignette. For the cubic 
#'   spline-based baseline hazards there is no intercept parameter since it is 
#'   absorbed into the spline basis and, therefore, the prior for the intercept 
#'   is effectively specified as part of \code{prior_aux}.  
#'   
#'   Where relevant, \code{prior_intercept} can be a call to \code{normal}, 
#'   \code{student_t} or \code{cauchy}. See the \link[=priors]{priors help page} 
#'   for details on these functions. Note however that default scale for 
#'   \code{prior_intercept} is 20 for \code{stan_surv} models (rather than 10,
#'   which is the default scale used for \code{prior_intercept} by most 
#'   \pkg{rstanarm} modelling functions). To omit a prior on the intercept 
#'   ---i.e., to use a flat (improper) uniform prior--- \code{prior_intercept} 
#'   can be set to \code{NULL}.
#' @param prior_aux The prior distribution for "auxiliary" parameters related to 
#'   the baseline hazard. The relevant parameters differ depending 
#'   on the type of baseline hazard specified in the \code{basehaz} 
#'   argument. The following applies:
#'   \itemize{
#'     \item \code{basehaz = "ms"}: the auxiliary parameters are the coefficients
#'     for the M-spline basis terms on the baseline hazard. These parameters
#'     have a lower bound at zero.
#'     \item \code{basehaz = "bs"}: the auxiliary parameters are the coefficients
#'     for the B-spline basis terms on the log baseline hazard. These parameters
#'     are unbounded.
#'     \item \code{basehaz = "exp"}: there is \strong{no} auxiliary parameter, 
#'     since the log scale parameter for the exponential distribution is 
#'     incorporated as an intercept in the linear predictor.
#'     \item \code{basehaz = "weibull"}: the auxiliary parameter is the Weibull 
#'     shape parameter, while the log scale parameter for the Weibull 
#'     distribution is incorporated as an intercept in the linear predictor.
#'     The auxiliary parameter has a lower bound at zero. 
#'     \item \code{basehaz = "gompertz"}: the auxiliary parameter is the Gompertz 
#'     scale parameter, while the log shape parameter for the Gompertz 
#'     distribution is incorporated as an intercept in the linear predictor.
#'     The auxiliary parameter has a lower bound at zero. 
#'   }
#'   Currently, \code{prior_aux} can be a call to \code{normal}, \code{student_t} 
#'   or \code{cauchy}. See \code{\link{priors}} for details on these functions. 
#'   To omit a prior ---i.e., to use a flat (improper) uniform prior--- set 
#'   \code{prior_aux} to \code{NULL}. 
#' @param prior_smooth This is only relevant when time-dependent effects are 
#'   specified in the model (i.e. the \code{tde()} function is used in the 
#'   model formula. When that is the case, \code{prior_smooth} determines the
#'   prior distribution given to the hyperparameter (standard deviation) 
#'   contained in a random-walk prior for the cubic B-spline coefficients used 
#'   to model the time-dependent coefficient. Lower values for the hyperparameter
#'   yield a less a flexible smooth function for the time-dependent coefficient. 
#'   Specifically, \code{prior_smooth} can be a call to \code{exponential} to 
#'   use an exponential distribution, or \code{normal}, \code{student_t} or 
#'   \code{cauchy}, which results in a half-normal, half-t, or half-Cauchy 
#'   prior. See \code{\link{priors}} for details on these functions. To omit a 
#'   prior ---i.e., to use a flat (improper) uniform prior--- set 
#'   \code{prior_smooth} to \code{NULL}. The number of hyperparameters depends
#'   on the model specification (i.e. the number of time-dependent effects
#'   specified in the model) but a scalar prior will be recylced as necessary
#'   to the appropriate length.
#'  
#' @details
#' \subsection{Time dependent effects (i.e. non-proportional hazards)}{
#'   By default, any covariate effects specified in the \code{formula} are
#'   included in the model under a proportional hazards assumption. To relax
#'   this assumption, it is possible to estimate a time-dependent coefficient
#'   for a given covariate. This can be specified in the model \code{formula}
#'   by wrapping the covariate name in the \code{tde()} function (note that
#'   this function is not an exported function, rather it is an internal function
#'   that can only be evaluated within the formula of a \code{stan_surv} call).
#'   
#'   For example, if we wish to estimate a time-dependent effect for the 
#'   covariate \code{sex} then we can specify \code{tde(sex)} in the 
#'   \code{formula}, e.g. \code{Surv(time, status) ~ tde(sex) + age + trt}. 
#'   The coefficient for \code{sex} will then be modelled 
#'   using a flexible smooth function based on a cubic B-spline expansion of 
#'   time. 
#'   
#'   The flexibility of the smooth function can be controlled in two ways:
#'   \itemize{
#'   \item First, through control of the prior distribution for the cubic B-spline 
#'   coefficients that are used to model the time-dependent coefficient.
#'   Specifically, one can control the flexibility of the prior through 
#'   the hyperparameter (standard deviation) of the random walk prior used
#'   for the B-spline coefficients; see the \code{prior_smooth} argument. 
#'   \item Second, one can increase or decrease the number of degrees of 
#'   freedom used for the cubic B-spline function that is used to model the 
#'   time-dependent coefficient. By default the cubic B-spline basis is 
#'   evaluated using 3 degrees of freedom (that is a cubic spline basis with  
#'   boundary knots at the limits of the time range, but no internal knots). 
#'   If you wish to increase the flexibility of the smooth function by using a 
#'   greater number of degrees of freedom, then you can specify this as part
#'   of the \code{tde} function call in the model formula. For example, to 
#'   use cubic B-splines with 7 degrees of freedom we could specify 
#'   \code{tde(sex, df = 7)} in the model formula instead of just
#'   \code{tde(sex)}. See the \strong{Examples} section below for more 
#'   details.
#'   }
#'   In practice, the default \code{tde()} function should provide sufficient 
#'   flexibility for model most time-dependent effects. However, it is worth
#'   noting that the reliable estimation of a time-dependent effect usually 
#'   requires a relatively large number of events in the data (e.g. >1000).
#' }
#'              
#' @examples
#' \donttest{
#' #---------- Proportional hazards
#' 
#' # Simulated data
#' library(simsurv)
#' covs <- data.frame(id  = 1:200, 
#'                    trt = stats::rbinom(200, 1L, 0.5))
#' d1 <- simsurv(lambdas = 0.1, 
#'               gammas  = 1.5, 
#'               betas   = c(trt = -0.5),
#'               x       = covs, 
#'               maxt    = 5)
#' d1 <- merge(d1, covs)
#' f1 <- Surv(eventtime, status) ~ trt
#' m1a <- stan_surv(f1, d1, basehaz = "ms",       chains=1,refresh=0,iter=600)
#' m1b <- stan_surv(f1, d1, basehaz = "exp",      chains=1,refresh=0,iter=600)
#' m1c <- stan_surv(f1, d1, basehaz = "weibull",  chains=1,refresh=0,iter=600)
#' m1d <- stan_surv(f1, d1, basehaz = "gompertz", chains=1,refresh=0,iter=600)
#' get_est <- function(x) { fixef(x)["trt"] }
#' do.call(rbind, lapply(list(m1a, m1b, m1c, m1d), get_est))
#' bayesplot::bayesplot_grid(plot(m1a), # compare baseline hazards 
#'                           plot(m1b), 
#'                           plot(m1c), 
#'                           plot(m1d), 
#'                           ylim = c(0, 0.8))
#' 
#' #---------- Left and right censored data
#' 
#' # Mice tumor data
#' m2 <- stan_surv(Surv(l, u, type = "interval2") ~ grp, 
#'                 data = mice, chains = 1, refresh = 0, iter = 600)
#' print(m2, 4)
#' 
#' #---------- Non-proportional hazards
#' 
#' # Simulated data
#' library(simsurv)
#' covs <- data.frame(id  = 1:250, 
#'                    trt = stats::rbinom(250, 1L, 0.5))
#' d3 <- simsurv(lambdas = 0.1, 
#'               gammas  = 1.5, 
#'               betas   = c(trt = -0.5),
#'               tde     = c(trt = 0.2),
#'               x       = covs, 
#'               maxt    = 5)
#' d3 <- merge(d3, covs)
#' m3 <- stan_surv(Surv(eventtime, status) ~ tde(trt), 
#'                 data = d3, chains = 1, refresh = 0, iter = 600)
#' print(m3, 4)
#' plot(m3, "tde") # time-dependent hazard ratio
#' }
#' 
stan_surv <- function(formula, 
                      data, 
                      basehaz         = "ms", 
                      basehaz_ops, 
                      qnodes          = 15, 
                      prior           = normal(), 
                      prior_intercept = normal(),
                      prior_aux       = normal(), 
                      prior_smooth    = exponential(autoscale = FALSE), 
                      prior_PD        = FALSE,
                      algorithm       = c("sampling", "meanfield", "fullrank"),
                      adapt_delta     = 0.95, ...) {

  #-----------------------------
  # Pre-processing of arguments
  #-----------------------------
  
  if (!requireNamespace("survival"))
    stop("the 'survival' package must be installed to use this function.")
  
  if (missing(basehaz_ops)) 
    basehaz_ops <- NULL
  if (missing(data) || !inherits(data, "data.frame"))
    stop("'data' must be a data frame.")
  
  dots      <- list(...)
  algorithm <- match.arg(algorithm)
  
  formula   <- parse_formula(formula, data)
  data      <- make_model_data(formula$tf_form, data) # row subsetting etc.
  
  #----------------
  # Construct data
  #----------------
 
  #----- model frame stuff
  
  mf_stuff <- make_model_frame(formula$tf_form, data)
  
  mf <- mf_stuff$mf # model frame
  mt <- mf_stuff$mt # model terms
  
  #----- dimensions and response vectors
  
  # entry and exit times for each row of data
  t_beg <- make_t(mf, type = "beg") # entry time
  t_end <- make_t(mf, type = "end") # exit  time
  t_upp <- make_t(mf, type = "upp") # upper time for interval censoring
  
  # ensure no event or censoring times are zero (leads to degenerate
  # estimate for log hazard for most baseline hazards, due to log(0))
  check1 <- any(t_end <= 0, na.rm = TRUE)
  check2 <- any(t_upp <= 0, na.rm = TRUE)
  if (check1 || check2)
    stop2("All event and censoring times must be greater than 0.")

  # event indicator for each row of data
  status <- make_d(mf)
  
  if (any(status < 0 || status > 3))
    stop2("Invalid status indicator in Surv object.")

  # delayed entry indicator for each row of data
  delayed  <- as.logical(!t_beg == 0)
  
  # time variables for stan
  t_event <- t_end[status == 1] # exact event time
  t_lcens <- t_end[status == 2] # left  censoring time
  t_rcens <- t_end[status == 0] # right censoring time
  t_icenl <- t_end[status == 3] # lower limit of interval censoring time
  t_icenu <- t_upp[status == 3] # upper limit of interval censoring time
  t_delay <- t_beg[delayed]     # delayed entry time
  
  # calculate log crude event rate
  t_tmp <- sum(rowMeans(cbind(t_end, t_upp), na.rm = TRUE) - t_beg)
  d_tmp <- sum(!status == 0)
  log_crude_event_rate = log(d_tmp / t_tmp)
  
  # dimensions
  nevent <- sum(status == 1)
  nrcens <- sum(status == 0)
  nlcens <- sum(status == 2)
  nicens <- sum(status == 3)
  ndelay <- sum(delayed)
  
  #----- baseline hazard

  ok_basehaz <- c("exp", "weibull", "gompertz", "ms", "bs")
  ok_basehaz_ops <- get_ok_basehaz_ops(basehaz)
  basehaz <- handle_basehaz_surv(basehaz        = basehaz, 
                                 basehaz_ops    = basehaz_ops, 
                                 ok_basehaz     = ok_basehaz,
                                 ok_basehaz_ops = ok_basehaz_ops,
                                 times          = t_end, 
                                 status         = status,
                                 min_t          = min(t_beg),
                                 max_t          = max(c(t_end,t_upp), na.rm = TRUE))
  nvars <- basehaz$nvars # number of basehaz aux parameters
  
  # flag if intercept is required for baseline hazard
  has_intercept   <- ai(has_intercept(basehaz))

  #----- define dimensions and times for quadrature

  # flag if formula uses time-dependent effects
  has_tde <- !is.null(formula$td_form)

  # flag if closed form available for cumulative baseline hazard
  has_closed_form <- check_for_closed_form(basehaz)

  # flag for quadrature
  has_quadrature <- has_tde || !has_closed_form
  
  if (has_quadrature) { # model uses quadrature
    
    # standardised weights and nodes for quadrature
    qq <- get_quadpoints(nodes = qnodes)
    qp <- qq$points
    qw <- qq$weights
    
    # quadrature points & weights, evaluated for each row of data
    qpts_event <- uapply(qp, unstandardise_qpts, 0, t_event)
    qpts_lcens <- uapply(qp, unstandardise_qpts, 0, t_lcens)
    qpts_rcens <- uapply(qp, unstandardise_qpts, 0, t_rcens)
    qpts_icenl <- uapply(qp, unstandardise_qpts, 0, t_icenl)
    qpts_icenu <- uapply(qp, unstandardise_qpts, 0, t_icenu)
    qpts_delay <- uapply(qp, unstandardise_qpts, 0, t_delay)
    
    qwts_event <- uapply(qw, unstandardise_qwts, 0, t_event)
    qwts_lcens <- uapply(qw, unstandardise_qwts, 0, t_lcens)
    qwts_rcens <- uapply(qw, unstandardise_qwts, 0, t_rcens)
    qwts_icenl <- uapply(qw, unstandardise_qwts, 0, t_icenl)
    qwts_icenu <- uapply(qw, unstandardise_qwts, 0, t_icenu)
    qwts_delay <- uapply(qw, unstandardise_qwts, 0, t_delay)
    
    # times at events and all quadrature points
    cpts_list <- list(t_event,
                      qpts_event,
                      qpts_lcens,
                      qpts_rcens,
                      qpts_icenl,
                      qpts_icenu,
                      qpts_delay)
    idx_cpts <- get_idx_array(sapply(cpts_list, length))
    cpts     <- unlist(cpts_list) # as vector for stan
    len_cpts <- length(cpts)

    # number of quadrature points
    qevent <- length(qwts_event)
    qlcens <- length(qwts_lcens)
    qrcens <- length(qwts_rcens)
    qicens <- length(qwts_icenl)
    qdelay <- length(qwts_delay)
        
  } else {
    
    cpts     <- rep(0,0)
    len_cpts <- 0L
    idx_cpts <- matrix(0,7,2)
    
    if (!qnodes == 15) # warn user if qnodes is not equal to the default
      warning2("There is no quadrature required so 'qnodes' is being ignored.")
  }

  #----- basis terms for baseline hazard

  if (has_quadrature) {
    
    basis_cpts <- make_basis(cpts, basehaz)   
    
  } else {
    
    basis_event  <- make_basis(t_event, basehaz)
    
    ibasis_event <- make_basis(t_event, basehaz, integrate = TRUE)
    ibasis_lcens <- make_basis(t_lcens, basehaz, integrate = TRUE)
    ibasis_rcens <- make_basis(t_rcens, basehaz, integrate = TRUE)
    ibasis_icenl <- make_basis(t_icenl, basehaz, integrate = TRUE)
    ibasis_icenu <- make_basis(t_icenu, basehaz, integrate = TRUE)
    ibasis_delay <- make_basis(t_delay, basehaz, integrate = TRUE)
 
  }
    
  #----- predictor matrices
  
  # time-fixed predictor matrix
  x_stuff <- make_x(formula$tf_form, mf)
  x          <- x_stuff$x
  x_bar      <- x_stuff$x_bar
  x_centered <- x_stuff$x_centered  
  x_event <- keep_rows(x_centered, status == 1)
  x_lcens <- keep_rows(x_centered, status == 2)
  x_rcens <- keep_rows(x_centered, status == 0)
  x_icens <- keep_rows(x_centered, status == 3)
  x_delay <- keep_rows(x_centered, delayed)
  K <- ncol(x)
  if (has_quadrature) {
    x_cpts <- rbind(x_event,
                    rep_rows(x_event, times = qnodes),
                    rep_rows(x_lcens, times = qnodes),
                    rep_rows(x_rcens, times = qnodes),
                    rep_rows(x_icens, times = qnodes),
                    rep_rows(x_icens, times = qnodes),
                    rep_rows(x_delay, times = qnodes))
  }
  
  # time-varying predictor matrix
  if (has_tde) { 
    tdfm  <- formula$td_form 
    xlevs <- .getXlevels(mt, mf)
    data_event <- keep_rows(data, status == 1)
    data_lcens <- keep_rows(data, status == 2)
    data_rcens <- keep_rows(data, status == 0)
    data_icens <- keep_rows(data, status == 3)
    data_delay <- keep_rows(data, delayed)
    data_cpts  <- rbind(data_event,
                        rep_rows(data_event, times = qnodes),
                        rep_rows(data_lcens, times = qnodes),
                        rep_rows(data_rcens, times = qnodes),
                        rep_rows(data_icens, times = qnodes),
                        rep_rows(data_icens, times = qnodes),
                        rep_rows(data_delay, times = qnodes))
    s_cpts <- make_s(tdfm, data_cpts, times = cpts, xlevs = xlevs)
    smooth_map <- get_smooth_name(s_cpts, type = "smooth_map")
    smooth_idx <- get_idx_array(table(smooth_map))
    S <- ncol(s_cpts) # num. of tde spline coefficients
  } else { # model does not have tde
    s_cpts     <- matrix(0,len_cpts,0)
    smooth_idx <- matrix(0,0,2)
    smooth_map <- integer(0)
    S          <- 0L
  }

  #----- stan data
  
  standata <- nlist(
    K, S, 
    nvars,
    x_bar,
    has_intercept, 
    has_quadrature,
    smooth_map,
    smooth_idx,
    cpts,
    len_cpts,
    idx_cpts,
    type = basehaz$type,
    log_crude_event_rate,
    
    nevent       = if (has_quadrature) 0L else nevent,
    nlcens       = if (has_quadrature) 0L else nlcens,
    nrcens       = if (has_quadrature) 0L else nrcens,
    nicens       = if (has_quadrature) 0L else nicens,
    ndelay       = if (has_quadrature) 0L else ndelay,
    
    t_event      = if (has_quadrature) rep(0,0) else t_event,
    t_lcens      = if (has_quadrature) rep(0,0) else t_lcens,
    t_rcens      = if (has_quadrature) rep(0,0) else t_rcens,
    t_icenl      = if (has_quadrature) rep(0,0) else t_icenl,
    t_icenu      = if (has_quadrature) rep(0,0) else t_icenu,
    t_delay      = if (has_quadrature) rep(0,0) else t_delay,
    
    x_event      = if (has_quadrature) matrix(0,0,K) else x_event,
    x_lcens      = if (has_quadrature) matrix(0,0,K) else x_lcens,
    x_rcens      = if (has_quadrature) matrix(0,0,K) else x_rcens,
    x_icens      = if (has_quadrature) matrix(0,0,K) else x_icens,
    x_delay      = if (has_quadrature) matrix(0,0,K) else x_delay,
    
    basis_event  = if (has_quadrature) matrix(0,0,nvars) else basis_event,
    ibasis_event = if (has_quadrature) matrix(0,0,nvars) else ibasis_event,
    ibasis_lcens = if (has_quadrature) matrix(0,0,nvars) else ibasis_lcens,
    ibasis_rcens = if (has_quadrature) matrix(0,0,nvars) else ibasis_rcens,
    ibasis_icenl = if (has_quadrature) matrix(0,0,nvars) else ibasis_icenl,
    ibasis_icenu = if (has_quadrature) matrix(0,0,nvars) else ibasis_icenu,
    ibasis_delay = if (has_quadrature) matrix(0,0,nvars) else ibasis_delay,
    
    qnodes       = if (!has_quadrature) 0L else qnodes,
    
    Nevent       = if (!has_quadrature) 0L else nevent,
    qevent       = if (!has_quadrature) 0L else qevent,
    qlcens       = if (!has_quadrature) 0L else qlcens,
    qrcens       = if (!has_quadrature) 0L else qrcens,
    qicens       = if (!has_quadrature) 0L else qicens,
    qdelay       = if (!has_quadrature) 0L else qdelay,
    Nlcens       = if (!has_quadrature) 0L else nlcens, 
    Nicens       = if (!has_quadrature) 0L else nicens,

    x_cpts       = if (!has_quadrature) matrix(0,0,K)     else x_cpts,
    s_cpts       = if (!has_quadrature) matrix(0,0,S)     else s_cpts,
    basis_cpts   = if (!has_quadrature) matrix(0,0,nvars) else basis_cpts,
    
    qwts_event   = if (!has_quadrature) rep(0,0) else qwts_event,
    qwts_lcens   = if (!has_quadrature) rep(0,0) else qwts_lcens,
    qwts_rcens   = if (!has_quadrature) rep(0,0) else qwts_rcens,
    qwts_icenl   = if (!has_quadrature) rep(0,0) else qwts_icenl,
    qwts_icenu   = if (!has_quadrature) rep(0,0) else qwts_icenu,
    qwts_delay   = if (!has_quadrature) rep(0,0) else qwts_delay
  )
  
  #----- priors and hyperparameters

  # valid priors
  ok_dists <- nlist("normal", 
                    student_t = "t", 
                    "cauchy", 
                    "hs", 
                    "hs_plus", 
                    "laplace", 
                    "lasso") # disallow product normal
  ok_intercept_dists <- ok_dists[1:3]
  ok_aux_dists       <- ok_dists[1:3]
  ok_smooth_dists    <- c(ok_dists[1:3], "exponential")
  
  # priors
  user_prior_stuff <- prior_stuff <-
    handle_glm_prior(prior, 
                     nvars = K,
                     default_scale = 2.5,
                     link = NULL,
                     ok_dists = ok_dists)
  
  user_prior_intercept_stuff <- prior_intercept_stuff <-
    handle_glm_prior(prior_intercept, 
                     nvars = 1,
                     default_scale = 20,
                     link = NULL,
                     ok_dists = ok_intercept_dists)
 
  user_prior_aux_stuff <- prior_aux_stuff <-
    handle_glm_prior(prior_aux, 
                     nvars = basehaz$nvars,
                     default_scale = get_default_aux_scale(basehaz),
                     link = NULL,
                     ok_dists = ok_aux_dists)

  user_prior_smooth_stuff <- prior_smooth_stuff <-
    handle_glm_prior(prior_smooth, 
                     nvars = if (S) max(smooth_map) else 0,
                     default_scale = 1,
                     link = NULL,
                     ok_dists = ok_smooth_dists)
  
  # stop null priors if prior_PD is TRUE
  if (prior_PD) {
    if (is.null(prior))
      stop("'prior' cannot be NULL if 'prior_PD' is TRUE")
    if (is.null(prior_intercept) && has_intercept)
      stop("'prior_intercept' cannot be NULL if 'prior_PD' is TRUE")
    if (is.null(prior_aux))
      stop("'prior_aux' cannot be NULL if 'prior_PD' is TRUE")    
    if (is.null(prior_smooth) && (S > 0))
      stop("'prior_smooth' cannot be NULL if 'prior_PD' is TRUE")    
  }
  
  # autoscaling of priors
  prior_stuff           <- autoscale_prior(prior_stuff, predictors = x)
  prior_intercept_stuff <- autoscale_prior(prior_intercept_stuff)
  prior_aux_stuff       <- autoscale_prior(prior_aux_stuff)
  prior_smooth_stuff    <- autoscale_prior(prior_smooth_stuff)
  
  # priors
  standata$prior_dist              <- prior_stuff$prior_dist
  standata$prior_dist_for_intercept<- prior_intercept_stuff$prior_dist
  standata$prior_dist_for_aux      <- prior_aux_stuff$prior_dist
  standata$prior_dist_for_smooth   <- prior_smooth_stuff$prior_dist
  
  # hyperparameters
  standata$prior_mean               <- prior_stuff$prior_mean
  standata$prior_scale              <- prior_stuff$prior_scale
  standata$prior_df                 <- prior_stuff$prior_df
  standata$prior_mean_for_intercept <- c(prior_intercept_stuff$prior_mean)
  standata$prior_scale_for_intercept<- c(prior_intercept_stuff$prior_scale)
  standata$prior_df_for_intercept   <- c(prior_intercept_stuff$prior_df)
  standata$prior_scale_for_aux      <- prior_aux_stuff$prior_scale
  standata$prior_df_for_aux         <- prior_aux_stuff$prior_df
  standata$prior_mean_for_smooth    <- prior_smooth_stuff$prior_mean
  standata$prior_scale_for_smooth   <- prior_smooth_stuff$prior_scale
  standata$prior_df_for_smooth      <- prior_smooth_stuff$prior_df
  standata$global_prior_scale       <- prior_stuff$global_prior_scale
  standata$global_prior_df          <- prior_stuff$global_prior_df
  standata$slab_df                  <- prior_stuff$slab_df
  standata$slab_scale               <- prior_stuff$slab_scale

  # any additional flags
  standata$prior_PD <- ai(prior_PD)
  
  #---------------
  # Prior summary
  #---------------
  
  prior_info <- summarize_jm_prior(
    user_priorEvent           = user_prior_stuff,
    user_priorEvent_intercept = user_prior_intercept_stuff,
    user_priorEvent_aux       = user_prior_aux_stuff,
    adjusted_priorEvent_scale           = prior_stuff$prior_scale,
    adjusted_priorEvent_intercept_scale = prior_intercept_stuff$prior_scale,
    adjusted_priorEvent_aux_scale       = prior_aux_stuff$prior_scale,
    e_has_intercept  = has_intercept,
    e_has_predictors = K > 0,
    basehaz = basehaz
  )
  
  #-----------
  # Fit model
  #-----------

  # obtain stan model code
  stanfit  <- stanmodels$surv
  
  # specify parameters for stan to monitor
  stanpars <- c(if (standata$has_intercept) "alpha",
                if (standata$K)             "beta",
                if (standata$S)             "beta_tde",
                if (standata$S)             "smooth_sd",
                if (standata$nvars)         "aux")
  
  # fit model using stan
  if (algorithm == "sampling") { # mcmc
    args <- set_sampling_args(
      object = stanfit, 
      data   = standata, 
      pars   = stanpars, 
      prior  = prior, 
      user_dots = list(...), 
      user_adapt_delta = adapt_delta, 
      show_messages = FALSE)
    stanfit <- do.call(rstan::sampling, args)
  } else { # meanfield or fullrank vb
    args <- nlist(
      object = stanfit,
      data   = standata,
      pars   = stanpars,
      algorithm
    )
    args[names(dots)] <- dots
    stanfit <- do.call(rstan::vb, args)
  }
  check_stanfit(stanfit)
  
  # define new parameter names
  nms_beta   <- colnames(x) # may be NULL
  nms_tde    <- get_smooth_name(s_cpts, type = "smooth_coefs") # may be NULL
  nms_smooth <- get_smooth_name(s_cpts, type = "smooth_sd")    # may be NULL
  nms_int    <- get_int_name_basehaz(basehaz)
  nms_aux    <- get_aux_name_basehaz(basehaz)
  nms_all    <- c(nms_int,
                  nms_beta,
                  nms_tde,
                  nms_smooth,
                  nms_aux,
                  "log-posterior")

  # substitute new parameter names into 'stanfit' object
  stanfit <- replace_stanfit_nms(stanfit, nms_all)

  # return an object of class 'stansurv'
  fit <- nlist(stanfit, 
               formula,
               has_tde,
               has_quadrature,
               data,
               model_frame      = mf,
               terms            = mt,
               xlevels          = .getXlevels(mt, mf),
               x,
               s_cpts           = if (has_tde) s_cpts else NULL,
               t_beg, 
               t_end,
               status,
               event            = as.logical(status == 1),
               delayed,
               basehaz,
               nobs             = nrow(mf),
               nevents          = nevent,
               nlcens,
               nrcens,
               nicens,
               ncensor          = nlcens + nrcens + nicens,
               ndelayed         = ndelay,
               prior_info,
               qnodes           = if (has_quadrature) qnodes else NULL,
               algorithm,
               stan_function    = "stan_surv",
               rstanarm_version = utils::packageVersion("rstanarm"),
               call             = match.call(expand.dots = TRUE))
  stansurv(fit)
}


#---------- internal

# Construct a list with information about the baseline hazard
#
# @param basehaz A string specifying the type of baseline hazard
# @param basehaz_ops A named list with elements df, knots 
# @param ok_basehaz A list of admissible baseline hazards
# @param times A numeric vector with eventtimes for each individual
# @param status A numeric vector with event indicators for each individual
# @param min_t Scalar, the minimum entry time across all individuals
# @param max_t Scalar, the maximum event or censoring time across all individuals
# @return A named list with the following elements:
#   type: integer specifying the type of baseline hazard, 1L = weibull,
#     2L = b-splines, 3L = piecewise.
#   type_name: character string specifying the type of baseline hazard.
#   user_df: integer specifying the input to the df argument
#   df: integer specifying the number of parameters to use for the 
#     baseline hazard.
#   knots: the knot locations for the baseline hazard.
#   bs_basis: The basis terms for the B-splines. This is passed to Stan
#     as the "model matrix" for the baseline hazard. It is also used in
#     post-estimation when evaluating the baseline hazard for posterior
#     predictions since it contains information about the knot locations
#     for the baseline hazard (this is implemented via splines::predict.bs). 
handle_basehaz_surv <- function(basehaz, 
                                basehaz_ops, 
                                ok_basehaz     = c("weibull", "bs", "piecewise"),
                                ok_basehaz_ops = c("df", "knots"),
                                times, 
                                status,
                                min_t, max_t) {
  
  if (!basehaz %in% ok_basehaz)
    stop2("'basehaz' should be one of: ", comma(ok_basehaz))
  
  if (!all(names(basehaz_ops) %in% ok_basehaz_ops))
    stop2("'basehaz_ops' can only include: ", comma(ok_basehaz_ops))
  
  if (basehaz == "exp") {
    
    bknots <- NULL # boundary knot locations
    iknots <- NULL # internal knot locations
    basis  <- NULL # spline basis
    nvars  <- 0L   # number of aux parameters, none
    
  } else if (basehaz == "gompertz") {
    
    bknots <- NULL # boundary knot locations
    iknots <- NULL # internal knot locations
    basis  <- NULL # spline basis
    nvars  <- 1L   # number of aux parameters, Gompertz scale
    
  } else if (basehaz == "weibull") {
    
    bknots <- NULL # boundary knot locations
    iknots <- NULL # internal knot locations
    basis  <- NULL # spline basis
    nvars  <- 1L   # number of aux parameters, Weibull shape
    
  } else if (basehaz == "bs") {
    
    df    <- basehaz_ops$df
    knots <- basehaz_ops$knots
    
    if (!is.null(df) && !is.null(knots))
      stop2("Cannot specify both 'df' and 'knots' for the baseline hazard.")
    
    if (is.null(df))
      df <- 6L # default df for B-splines, assuming an intercept is included
    # NB this is ignored if the user specified knots
    
    tt <- times[status == 1] # uncensored event times
    if (is.null(knots) && !length(tt)) {
      warning2("No observed events found in the data. Censoring times will ",
               "be used to evaluate default knot locations for splines.")
      tt <- times
    }
    
    if (!is.null(knots)) {
      if (any(knots < min_t))
        stop2("'knots' cannot be placed before the earliest entry time.")
      if (any(knots > max_t))
        stop2("'knots' cannot be placed beyond the latest event time.")
    } 
        
    bknots <- c(min_t, max_t)
    iknots <- get_iknots(tt, df = df, iknots = knots)
    basis  <- get_basis(tt, iknots = iknots, bknots = bknots, type = "bs")      
    nvars  <- ncol(basis)  # number of aux parameters, basis terms
    
  } else if (basehaz == "ms") {
    
    df    <- basehaz_ops$df
    knots <- basehaz_ops$knots
    
    if (!is.null(df) && !is.null(knots)) {
      stop2("Cannot specify both 'df' and 'knots' for the baseline hazard.")
    }
    
    tt <- times[status == 1] # uncensored event times
    if (is.null(df)) {
      df <- 6L # default df for M-splines, assuming an intercept is included
      # NB this is ignored if the user specified knots
    }

    tt <- times[status == 1] # uncensored event times
    if (is.null(knots) && !length(tt)) {
      warning2("No observed events found in the data. Censoring times will ",
               "be used to evaluate default knot locations for splines.")
      tt <- times
    }    
    
    if (!is.null(knots)) {
      if (any(knots < min_t))
        stop2("'knots' cannot be placed before the earliest entry time.")
      if (any(knots > max_t))
        stop2("'knots' cannot be placed beyond the latest event time.")
    }
    
    bknots <- c(min_t, max_t)
    iknots <- get_iknots(tt, df = df, iknots = knots)
    basis  <- get_basis(tt, iknots = iknots, bknots = bknots, type = "ms")      
    nvars  <- ncol(basis)  # number of aux parameters, basis terms
    
  } else if (basehaz == "piecewise") {
    
    df    <- basehaz_ops$df
    knots <- basehaz_ops$knots
    
    if (!is.null(df) && !is.null(knots)) {
      stop2("Cannot specify both 'df' and 'knots' for the baseline hazard.")
    }
    
    if (is.null(df)) {
      df <- 6L # default number of segments for piecewise constant
      # NB this is ignored if the user specified knots
    }

    if (is.null(knots) && !length(tt)) {
      warning2("No observed events found in the data. Censoring times will ",
               "be used to evaluate default knot locations for piecewise basehaz.")
      tt <- times
    }    
    
    if (!is.null(knots)) {
      if (any(knots < min_t))
        stop2("'knots' cannot be placed before the earliest entry time.")
      if (any(knots > max_t))
        stop2("'knots' cannot be placed beyond the latest event time.")
    }
    
    bknots <- c(min_t, max_t)
    iknots <- get_iknots(tt, df = df, iknots = knots)
    basis  <- NULL               # spline basis
    nvars  <- length(iknots) + 1 # number of aux parameters, dummy indicators
    
  }  
  
  nlist(type_name = basehaz, 
        type = basehaz_for_stan(basehaz), 
        nvars, 
        iknots, 
        bknots, 
        basis,
        df = nvars,
        user_df = nvars,
        knots = if (basehaz == "bs") iknots else c(bknots[1], iknots, bknots[2]),
        bs_basis = basis)
}

# Return a vector with valid names for elements in the list passed to the
# 'basehaz_ops' argument of a 'stan_jm' or 'stan_surv' call
#
# @param basehaz_name A character string, the type of baseline hazard.
# @return A character vector, or NA if unmatched.
get_ok_basehaz_ops <- function(basehaz_name) {
  switch(basehaz_name,
         weibull   = c(),
         bs        = c("df", "knots"),
         piecewise = c("df", "knots"),
         ms        = c("df", "knots"),
         NA)
}

# Return the integer respresentation for the baseline hazard, used by Stan
#
# @param basehaz_name A character string, the type of baseline hazard.
# @return An integer, or NA if unmatched.
basehaz_for_stan <- function(basehaz_name) {
  switch(basehaz_name, 
         weibull   = 1L, 
         bs        = 2L,
         piecewise = 3L,
         ms        = 4L,
         exp       = 5L,
         gompertz  = 6L,
         NA)
}

# Return a vector with internal knots for 'x', based on evenly spaced quantiles
#
# @param x A numeric vector.
# @param df The degrees of freedom. If specified, then 'df - degree - intercept'.
#   knots are placed at evenly spaced percentiles of 'x'. If 'iknots' is 
#   specified then 'df' is ignored.
# @return A numeric vector of internal knot locations, or NULL if there are
#   no internal knots.
get_iknots <- function(x, df = 6L, degree = 3L, iknots = NULL, intercept = TRUE) {
  
  # obtain number of internal knots
  if (is.null(iknots)) {
    nk <- df - degree - intercept
  } else {
    nk <- length(iknots)
  }
  
  # validate number of internal knots
  if (nk < 0) {
    stop2("Number of internal knots cannot be negative.")
  }
  
  # obtain default knot locations if necessary
  if (is.null(iknots)) {
    iknots <- qtile(x, nq = nk + 1)  # evenly spaced percentiles
  }
  
  # return internal knot locations, ensuring they are positive
  validate_positive_scalar(iknots)
  
  return(iknots)
}

# Identify whether the type of baseline hazard requires an intercept in
# the linear predictor (NB splines incorporate the intercept into the basis).
#
# @param basehaz A list with info about the baseline hazard; see 'handle_basehaz'.
# @return A Logical.
has_intercept <- function(basehaz) {
  nm <- get_basehaz_name(basehaz)
  (nm %in% c("exp", "weibull", "gompertz"))
}

# Return the name of the tde spline coefs or smoothing parameters.
#
# @param x The predictor matrix for the time-dependent effects, with column names.
# @param type The type of information about the smoothing parameters to return.
# @return A character or numeric vector, depending on 'type'.
get_smooth_name <- function(x, type = "smooth_coefs") {
  
  if (is.null(x) || !ncol(x))
    return(NULL)  

  nms <- gsub(":bs\\(times__.*\\)[0-9]*$", "", colnames(x))
  tally   <- table(nms)
  indices <- uapply(tally, seq_len)
  suffix  <- paste0(":tde-spline-coef", indices)
  
  switch(type,
         smooth_coefs = paste0(nms, suffix),
         smooth_sd    = paste0("smooth_sd[", unique(nms), "]"),
         smooth_map   = rep(seq_along(tally), tally),
         smooth_vars  = unique(nms),
         stop2("Bug found: invalid input to 'type' argument."))
}

# Return the default scale parameter for 'prior_aux'.
#
# @param basehaz A list with info about the baseline hazard; see 'handle_basehaz'.
# @return A scalar.
get_default_aux_scale <- function(basehaz) {
  nm <- get_basehaz_name(basehaz)
  if (nm %in% c("weibull", "gompertz")) 2 else 20
}

# Check if the type of baseline hazard has a closed form
#
# @param basehaz A list with info about the baseline hazard; see 'handle_basehaz'.
# @return A logical.
check_for_closed_form <- function(basehaz) {
  nm <- get_basehaz_name(basehaz)
  nm %in% c("exp",
            "weibull",
            "gompertz",
            "ms")
}

# Replace the parameter names slot of an object of class 'stanfit'.
#
# @param stanfit An object of class 'stanfit'.
# @param new_nms A character vector of new parameter names.
# @return A 'stanfit' object.
replace_stanfit_nms <- function(stanfit, new_nms) {
  stanfit@sim$fnames_oi <- new_nms
  stanfit
}

# Return the spline basis for the given type of baseline hazard.
# 
# @param times A numeric vector of times at which to evaluate the basis.
# @param basehaz A list with info about the baseline hazard, returned by a 
#   call to 'handle_basehaz'.
# @param integrate A logical, specifying whether to calculate the integral of
#   the specified basis.
# @return A matrix.
make_basis <- function(times, basehaz, integrate = FALSE) {
  N <- length(times)
  K <- basehaz$nvars
  if (!N) { # times is NULL or empty vector
    return(matrix(0, 0, K))
  } 
  switch(basehaz$type_name,
         "exp"       = matrix(0, N, K), # dud matrix for Stan
         "weibull"   = matrix(0, N, K), # dud matrix for Stan
         "gompertz"  = matrix(0, N, K), # dud matrix for Stan
         "ms"        = basis_matrix(times, basis = basehaz$basis, integrate = integrate),
         "bs"        = basis_matrix(times, basis = basehaz$basis),
         "piecewise" = dummy_matrix(times, knots = basehaz$knots),
         stop2("Bug found: type of baseline hazard unknown."))
}

# Evaluate a spline basis matrix at the specified times
#
# @param time A numeric vector.
# @param basis Info on the spline basis.
# @param integrate A logical, should the integral of the basis be returned?
# @return A two-dimensional array.
basis_matrix <- function(times, basis, integrate = FALSE) {
  out <- predict(basis, times)
  if (integrate) {
    stopifnot(inherits(basis, "mSpline"))
    class(basis) <- c("matrix", "iSpline")
    out <- predict(basis, times)
  }
  aa(out)
}

# Parse the model formula
#
# @param formula The user input to the formula argument.
# @param data The user input to the data argument (i.e. a data frame).
parse_formula <- function(formula, data) {
  
  formula <- validate_formula(formula, needs_response = TRUE)
  
  lhs      <- lhs(formula) # full LHS of formula
  lhs_form <- reformulate_lhs(lhs)
  
  rhs        <- rhs(formula)         # RHS as expression
  rhs_form   <- reformulate_rhs(rhs) # RHS as formula
  rhs_terms  <- terms(rhs_form, specials = "tde")
  rhs_vars   <- rownames(attr(rhs_terms, "factors"))
  
  allvars <- all.vars(formula)
  allvars_form <- reformulate(allvars)
  
  surv <- eval(lhs, envir = data) # Surv object
  surv <- validate_surv(surv)
  type <- attr(surv, "type")
  
  if (type == "right") {
    tvar_beg <- NULL
    tvar_end <- as.character(lhs[[2L]])
    dvar     <- as.character(lhs[[3L]])
    min_t    <- 0
    max_t    <- max(surv[, "time"])
  } else if (type == "counting") {
    tvar_beg <- as.character(lhs[[2L]])
    tvar_end <- as.character(lhs[[3L]])
    dvar     <- as.character(lhs[[4L]])
    min_t    <- min(surv[, "start"])
    max_t    <- max(surv[, "stop"])
  } else if (type == "interval") {
    tvar_beg <- NULL
    tvar_end <- as.character(lhs[[2L]])
    dvar     <- as.character(lhs[[4L]])
    min_t    <- 0
    max_t    <-  max(surv[, c("time1", "time2")])
  } else if (type == "interval2") {
    tvar_beg <- NULL
    tvar_end <- as.character(lhs[[2L]])
    dvar     <- as.character(lhs[[3L]])
    min_t    <- 0
    max_t    <- max(surv[, c("time1", "time2")])
  }

  sel <- attr(rhs_terms, "specials")$tde
  
  if (!is.null(sel)) { # model has tde
    
    # replace 'tde(x, ...)' in formula with 'x'
    tde_oldvars <- rhs_vars
    tde_newvars <- sapply(tde_oldvars, function(oldvar) {
      if (oldvar %in% rhs_vars[sel]) {
        tde <- function(newvar, ...) { # define tde function locally
          safe_deparse(substitute(newvar)) 
        }
        eval(parse(text = oldvar))
      } else oldvar
    }, USE.NAMES = FALSE)
    term_labels <- attr(rhs_terms, "term.labels")
    for (i in sel) {
      sel_terms <- which(attr(rhs_terms, "factors")[i, ] > 0)
      for (j in sel_terms) {
        term_labels[j] <- gsub(tde_oldvars[i], 
                               tde_newvars[i], 
                               term_labels[j], 
                               fixed = TRUE)
      }
    }
    tf_form <- reformulate(term_labels, response = lhs)
    
    # extract 'tde(x, ...)' from formula and construct 'bs(times, ...)'
    tde_terms <- lapply(rhs_vars[sel], function(x) {
      tde <- function(vn, ...) { # define tde function locally
        dots <- list(...)
        ok_args <- c("df")
        if (!isTRUE(all(names(dots) %in% ok_args)))
          stop2("Invalid argument to 'tde' function. ",
                "Valid arguments are: ", comma(ok_args))
        df <- if (is.null(dots$df)) 3 else dots$df
        degree <- 3
        if (df == 3) {
          dots[["knots"]] <- numeric(0)
        } else {
          dx <- (max_t - min_t) / (df - degree + 1)
          dots[["knots"]] <- seq(min_t + dx, max_t - dx, dx)
        }
        dots[["Boundary.knots"]] <- c(min_t, max_t) 
        sub("^list\\(", "bs\\(times__, ", safe_deparse(dots))
      }
      tde_calls <- eval(parse(text = x))
      sel_terms <- which(attr(rhs_terms, "factors")[x, ] > 0)
      new_calls <- sapply(seq_along(sel_terms), function(j) {
        paste0(term_labels[sel_terms[j]], ":", tde_calls)
      })
      nlist(tde_calls, new_calls)
    })
    td_basis <- fetch(tde_terms, "tde_calls")
    new_calls <- fetch_(tde_terms, "new_calls")
    td_form <- reformulate(new_calls, response = NULL, intercept = FALSE)
    
  } else { # model doesn't have tde
    tf_form  <- formula
    td_form  <- NULL
    td_basis <- NULL
  }

  nlist(formula,
        lhs,
        rhs,
        lhs_form,
        rhs_form,
        tf_form,
        td_form,
        td_basis,
        fe_form = rhs_form, # no re terms accommodated yet
        re_form = NULL,     # no re terms accommodated yet
        allvars,
        allvars_form,
        tvar_beg,
        tvar_end,
        dvar,
        surv_type = attr(surv, "type"))
}

# Check formula object
#
# @param formula The user input to the formula argument.
# @param needs_response A logical; if TRUE then formula must contain a LHS.
validate_formula <- function(formula, needs_response = TRUE) {
  
  if (!inherits(formula, "formula")) {
    stop2("'formula' must be a formula.")
  }
  
  if (needs_response) {
    len <- length(formula)
    if (len < 3) {
      stop2("'formula' must contain a response.")
    }
  }
  as.formula(formula)
}

# Check object is a Surv object with a valid type
#
# @param x A Surv object; the LHS of a formula evaluated in a data frame environment.
# @param ok_types A character vector giving the allowed types of Surv object.
validate_surv <- function(x, ok_types = c("right", "counting",
                                          "interval", "interval2")) {
  if (!inherits(x, "Surv"))
    stop2("LHS of 'formula' must be a 'Surv' object.")
  if (!attr(x, "type") %in% ok_types)
    stop2("Surv object type must be one of: ", comma(ok_types))
  x
}


# Extract LHS of a formula
#
# @param x A formula object
# @param as_formula Logical. If TRUE then the result is reformulated.
lhs <- function(x, as_formula = FALSE) {
  len <- length(x)
  if (len == 3L) {
    out <- x[[2L]]
  } else {
    out <- NULL
  }
  out
}

# Extract RHS of a formula
#
# @param x A formula object
# @param as_formula Logical. If TRUE then the result is reformulated.
rhs <- function(x, as_formula = FALSE) {
  len <- length(x)
  if (len == 3L) {
    out <- x[[3L]]
  } else {
    out <- x[[2L]]
  }
  out
}

# Reformulate as LHS of a formula
#
# @param x A character string or expression object
# @param as_formula Logical. If TRUE then the result is reformulated.
reformulate_lhs <- function(x) {
  #x <- deparse(x, 500L)
  x <- formula(substitute(LHS ~ 1, list(LHS = x)))
  x
}

# Reformulate as RHS of a formula
#
# @param x A formula object
# @param as_formula Logical. If TRUE then the result is reformulated.
reformulate_rhs <- function(x) {
  #x <- deparse(x, 500L)
  x <- formula(substitute(~ RHS, list(RHS = x)))
  x
}


# Return the response vector (time) for estimation
#
# @param model_frame The model frame.
# @param type The type of time variable to return:
#   "beg": the entry time for the row in the survival data,
#   "end": the exit  time for the row in the survival data,
#   "gap": the difference between entry and exit times,
#   "upp": if the row involved interval censoring, then the exit time
#          would have been the lower limit of the interval, and "upp" 
#          is the upper limit of the interval.
# @return A numeric vector.
make_t <- function(model_frame, type = c("beg", "end", "gap", "upp")) {
  
  type <- match.arg(type)
  resp <- if (survival::is.Surv(model_frame)) 
    model_frame else model.response(model_frame)
  surv <- attr(resp, "type")
  err  <- paste0("Bug found: cannot handle '", surv, "' Surv objects.")
  
  t_beg <- switch(surv,
                  "right"     = rep(0, nrow(model_frame)),
                  "interval"  = rep(0, nrow(model_frame)),
                  "interval2" = rep(0, nrow(model_frame)),
                  "counting"  = as.vector(resp[, "start"]),
                  stop(err))

  t_end <- switch(surv,
                  "right"     = as.vector(resp[, "time"]),
                  "interval"  = as.vector(resp[, "time1"]),
                  "interval2" = as.vector(resp[, "time1"]),
                  "counting"  = as.vector(resp[, "stop"]),
                  stop(err))

  t_upp <- switch(surv,
                  "right"     = rep(NaN, nrow(model_frame)),
                  "counting"  = rep(NaN, nrow(model_frame)),
                  "interval"  = as.vector(resp[, "time2"]),
                  "interval2" = as.vector(resp[, "time2"]),
                  stop(err))

  switch(type,
         "beg" = t_beg,
         "end" = t_end,
         "gap" = t_end - t_beg,
         "upp" = t_upp,
         stop("Bug found: cannot handle specified 'type'."))
}


# Return the response vector (status indicator)
#
# @param model_frame The model frame.
# @return A numeric vector.
make_d <- function(model_frame) {
  
  resp <- if (survival::is.Surv(model_frame)) 
    model_frame else model.response(model_frame)
  surv <- attr(resp, "type")
  err  <- paste0("Bug found: cannot handle '", surv, "' Surv objects.")
  
  switch(surv,
         "right"     = as.vector(resp[, "status"]),
         "interval"  = as.vector(resp[, "status"]),
         "interval2" = as.vector(resp[, "status"]),
         "counting"  = as.vector(resp[, "status"]),
         stop(err))
}

# Return a data frame with NAs excluded
#
# @param formula The parsed model formula.
# @param data The user specified data frame.
make_model_data <- function(formula, data) {
  mf <- model.frame(formula, data, na.action = na.pass)
  include <- apply(mf, 1L, function(row) !any(is.na(row)))
  data[include, , drop = FALSE]
}

# Return the model frame
#
# @param formula The parsed model formula.
# @param data The model data frame.
make_model_frame <- function(formula, data, check_constant = TRUE) {

  # construct terms object from formula 
  Terms <- terms(formula)
  
  # construct model frame
  mf <- model.frame(Terms, data)
  
  # check no constant vars
  if (check_constant)
    mf <- check_constant_vars(mf)
  
  # check for terms
  mt <- attr(mf, "terms")
  if (is.empty.model(mt)) 
    stop2("No intercept or predictors specified.")
  
  nlist(mf, mt)
}

# Return the fe predictor matrix for estimation
#
# @param formula The parsed model formula.
# @param model_frame The model frame.
# @return A named list with the following elements:
#   x: the fe model matrix, not centred and without intercept.
#   x_bar: the column means of the model matrix.
#   x_centered: the fe model matrix, centered.
#   N,K: number of rows (observations) and columns (predictors) in the
#     fixed effects model matrix
make_x <- function(formula, model_frame, xlevs = NULL, check_constant = TRUE) {

  # uncentred predictor matrix, without intercept
  x <- model.matrix(formula, model_frame, xlevs = xlevs)
  x <- drop_intercept(x)
  
  # column means of predictor matrix
  x_bar <- aa(colMeans(x))
  
  # centered predictor matrix
  x_centered <- sweep(x, 2, x_bar, FUN = "-")
  
  # identify any column of x with < 2 unique values (empty interaction levels)
  sel <- (apply(x, 2L, n_distinct) < 2)
  if (check_constant && any(sel)) {
    cols <- paste(colnames(x)[sel], collapse = ", ")
    stop2("Cannot deal with empty interaction levels found in columns: ", cols)
  }
  
  nlist(x, x_centered, x_bar, N = NROW(x), K = NCOL(x))
}

# Return a predictor for the tde spline terms
#
# @param formula The formula for the time-dependent effects part of the model.
# @param data A data frame.
# @param times The vector of times at which the predictor matrix should be 
#   evaluated.
# @param xlevs The factor levels to use for the predictor matrix.
# @return A matrix.
make_s <- function(formula, data, times, xlevs = NULL) {
  
  # add times (as a new variable) to the model data
  if (!length(times) == nrow(data))
    stop("Bug found: 'times' is the incorrect length.")
  data <- data.frame(data, times__ = times)

  # make model frame and predictor matrix
  mf <- make_model_frame(formula, data, check_constant = FALSE)$mf
  x  <- make_x(formula, mf, xlevs = xlevs, check_constant = FALSE)$x
  return(x)
}

# Return the fe predictor matrix for prediction
#
# @param object A stansurv object.
# @param model_frame The model frame.
# @return A named list with the following elements:
#   x: the fe model matrix, not centred and may have intercept depending on
#     the requirement of the baseline hazard.
#   N,K: number of rows (observations) and columns (predictors) in the
#     fixed effects model matrix
make_pp_x <- function(object, model_frame) {
  
  # formula for fe predictor matrix
  tt <- delete.response(terms(object))
  
  # check data classes in the model frame match those used in model fitting
  if (!is.null(cl <- attr(tt, "dataClasses"))) 
    .checkMFClasses(cl, model_frame)
  
  # uncentered predictor matrix
  x <- model.matrix(tt, model_frame, contrasts.arg = object$contrasts)
  
  # drop intercept if baseline hazard doesn't require one
  if (!has_intercept(object$basehaz))
    x <- drop_intercept(x)
  
  nlist(x, N = NROW(x), K = NCOL(x))  
}

# apply b-spline time-dependent effect
apply_tde_fun <- function(model_terms, model_frame, times, bknots = NULL) {
  
  tde_stuff <- survival::untangle.specials(model_terms, "tde")

  if (!length(tde_stuff$terms)) 
    return(model_frame) # no time-dependent effects
  
  if (!nrow(model_frame))
    return(model_frame) # no rows in model frame (e.g. no delayed entry)
  
  vars  <- attr(model_terms, 'variables')
  pvars <- attr(model_terms, 'predvars')
  
  # loop over time-dependent terms in formula
  K <- length(tde_stuff$terms)
  for (i in 1:K) { 
    indx_i <- tde_stuff$terms[i] + 2 # index in call; +2 for 'list' & 'Surv()'
    var_i  <- vars [[indx_i]]        # var     in formula
    pvar_i <- pvars[[indx_i]]        # predvar in formula
    var_i  <- safe_deparse(var_i)    # treat call as a string
    pvar_i <- safe_deparse(pvar_i)   # treat call as a string
    # get the possible prefixes for the predvar (i.e. 'tde(x' or 'bs(x')
    prefix <- "^bs\\([^,]+,[[:blank:]]*|^tde\\([^,]+,[[:blank:]]*"
    # returns dots from 'tde(x, ...)' as a list
    chck <- grepl(prefix, pvar_i)
    if (chck) {
      args_i <- eval_string(sub(prefix, "list\\(", pvar_i)) 
    } else {
      args_i <- list()
    }
    # combine the dots with the times at which to evaluate the b-spline basis
    args_i$intercept <- TRUE
    if (!is.null(bknots))
      args_i$Boundary.knots <- bknots
    args_i <- c(list(x = times), args_i)
    # extract the variable from the model frame
    oldx_i  <- model_frame[[var_i]]
    # apply interaction with the b-spline basis evaluated at specified times
    newx_i <- oldx_i * do.call(splines::bs, args_i)
    # substitute back into the model frame
    model_frame[[var_i]] <- newx_i
  }
  
  return(model_frame)
}

update_tde_terms <- function(model_terms, model_frame) {
  tde_terms <- survival::untangle.specials(model_terms, "tde")$terms
  if (!length(tde_terms))
    return(model_frame) # no time-dependent effects
  vars  <- attr(model_terms, 'variables')
  pvars <- attr(model_terms, 'predvars')
  dclss <- attr(model_terms, "dataClasses")
  K <- length(tde_terms)
  for (i in 1:K) {
    indx_i <- tde_terms[i] + 2       # index in call; +2 for 'list' & 'Surv()'
    var_i  <- vars [[indx_i]]        # var     in formula
    pvar_i <- pvars[[indx_i]]        # predvar in formula
    var_i  <- safe_deparse(var_i)    # treat call as a string
    pvar_i <- safe_deparse(pvar_i)   # treat call as a string
    oldx_i <- model_frame[[var_i]]   # extract transformed variable from model frame
    dummy  <- as.call(list(as.name(class(oldx_i)[[1L]]), vars[[indx_i]][[2]]))
    ptemp  <- makepredictcall(oldx_i, dummy) # predvars call
    pvars[[indx_i]] <- ptemp
    dclss[[var_i]] <- class(oldx_i)[[1L]]
  }
  attr(model_terms, "predvars") <- pvars
  #attr(model_terms, "dataClasses") <- dclss
  return(model_terms)
}


#--------- not used; based on tt approach instead of tde approach

# # Validate the user input to the 'tt' argument. This draws on the 
# # code for the coxph modelling function in the survival package.
# #
# # Copyright (C) 2018 Sam Brilleman
# # Copyright (C) 2018 Terry Therneau, Thomas Lumley
# #
# # @param tt The user input to the 'tt' argument.
# # @param validate_length Integer specifying the required length of the 
# #   returned list.
# # @return A list of functions.
# validate_tt_fun <- function(tt, validate_length) {
#   
#   if (is.null(tt))
#     stop2("'tt' must be specified.")
#   
#   if (is.function(tt)) 
#     tt <- list(tt) # convert since function to a one element list
#   
#   if (!is.list(tt))
#     stop2("The 'tt' argument must contain a function or list of functions.")  
#   
#   if (!all(sapply(tt, is.function)))
#     stop2("The 'tt' argument must contain function or list of functions.")
#   
#   if (!length(tt) %in% c(1, validate_length)) 
#     stop2("The 'tt' argument contains a list of the incorrect length.")
#   
#   if (length(tt) == 1)
#     tt <- rep(tt, validate_length)
#   
#   return(tt)
# }
# 
# # apply time transform to the model frame; method based on survival package 
# apply_tt_fun <- function(model_frame, tt_funs, tt_vars, tt_terms, times) {
#   if (!length(tt_terms))
#     return(model_frame)
#   
#   for (i in 1:length(tt_terms)) { # loop over time transform terms
#     
#     # extract quantities used in time transform
#     varnm_i <- tt_vars[[i]] # varname in model frame
#     ttfun_i <- tt_funs[[i]] # user defined tt function
#     
#     # time transform at event times
#     oldx_i <- model_frame[[varnm_i]]   # extract var from model frame
#     newx_i <- (ttfun_i)(oldx_i, times) # evaluate tt function at times
#     model_frame[[varnm_i]] <- newx_i   # substitute back into model frame
#   }
#   
#   return(model_frame)
# }
#
# # update the predvars attribute for time transformed terms
# update_predvars <- function(model_terms, model_frame, tt_vars, tt_terms) {
#   tcall <- attr(model_terms, 'variables')[tt_terms + 2]
#   pvars <- attr(model_terms, 'predvars')
#   pmethod <- sub("makepredictcall.", "", as.vector(methods("makepredictcall")))
#   for (i in 1:length(tt_terms)) {
#     # update predvars if necessary
#     varnm_i <- tt_vars[[i]]       # varname in model frame
#     terms_i <- tt_terms[i] + 2    # index in terms object
#     x_i <- model_frame[[varnm_i]] # extract transformed variable from model frame
#     nclass <- class(x_i)          # check class of transformed variable
#     if (any(nclass %in% pmethod)) { # it has a makepredictcall method...
#       dummy <- as.call(list(as.name(class(x_i)[1]), tcall[[i]][[2]]))
#       ptemp <- makepredictcall(x_i, dummy)
#       pvars[[terms_i]] <- ptemp
#     }
#   }
#   attr(model_terms, "predvars") <- pvars
#   return(model_terms)
# }

